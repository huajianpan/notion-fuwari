---
// Three.js 点阵海潮背景组件
// 支持鼠标交互和动态波浪效果
import { siteConfig } from "@/config";

const config = siteConfig.waveBackground;
---

<canvas id="wave-background" class="fixed top-0 left-0 w-full h-full -z-10" style={`opacity: ${config.opacity}`}></canvas>

<script>
import * as THREE from 'three';
import { siteConfig } from '@/config';

// 从配置读取参数
const config = siteConfig.waveBackground;

let scene: THREE.Scene;
let camera: THREE.PerspectiveCamera;
let renderer: THREE.WebGLRenderer;
let particles: THREE.Points;
let positions: Float32Array;
let originalPositions: Float32Array;
let mouse = new THREE.Vector2(0, 0);
let targetMouse = new THREE.Vector2(0, 0);
let animationId: number;
let time = 0;

function init() {
	const canvas = document.getElementById('wave-background') as HTMLCanvasElement;
	if (!canvas) return;

	// 如果已经初始化过，先清理
	if (animationId) {
		cleanup();
	}

	// 重置时间
	time = 0;
	mouse.set(0, 0);
	targetMouse.set(0, 0);

	// 场景设置
	scene = new THREE.Scene();

	// 相机设置
	camera = new THREE.PerspectiveCamera(
		75,
		window.innerWidth / window.innerHeight,
		0.1,
		1000
	);
	camera.position.z = 400;
	camera.position.y = 100;
	camera.lookAt(0, 0, 0);

	// 渲染器设置
	renderer = new THREE.WebGLRenderer({
		canvas,
		alpha: true,
		antialias: true
	});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

	// 创建点阵网格
	createParticleGrid();

	// 事件监听
	window.addEventListener('mousemove', onMouseMove);
	window.addEventListener('resize', onWindowResize);

	// 开始动画循环
	animate();
}

function createParticleGrid() {
	const count = config.gridSize * config.gridSize;
	const geometry = new THREE.BufferGeometry();

	positions = new Float32Array(count * 3);
	originalPositions = new Float32Array(count * 3);
	const colors = new Float32Array(count * 3);

	let index = 0;
	const offset = (config.gridSize * config.spacing) / 2;

	// 生成网格点
	for (let i = 0; i < config.gridSize; i++) {
		for (let j = 0; j < config.gridSize; j++) {
			const x = i * config.spacing - offset;
			const z = j * config.spacing - offset;
			const y = 0;

			positions[index * 3] = x;
			positions[index * 3 + 1] = y;
			positions[index * 3 + 2] = z;

			originalPositions[index * 3] = x;
			originalPositions[index * 3 + 1] = y;
			originalPositions[index * 3 + 2] = z;

			// 颜色渐变 (根据主题色调整)
			const color = new THREE.Color();
			const hue = (i / config.gridSize) * 0.3 + 0.5; // 蓝绿色系
			color.setHSL(hue, 0.7, 0.6);
			colors[index * 3] = color.r;
			colors[index * 3 + 1] = color.g;
			colors[index * 3 + 2] = color.b;

			index++;
		}
	}

	geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
	geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

	// 粒子材质
	const material = new THREE.PointsMaterial({
		size: config.particleSize,
		vertexColors: true,
		transparent: true,
		opacity: 0.8,
		sizeAttenuation: true,
		blending: THREE.AdditiveBlending,
	});

	particles = new THREE.Points(geometry, material);
	scene.add(particles);
}

function onMouseMove(event: MouseEvent) {
	// 将鼠标坐标转换为 Three.js 坐标系 (-1 到 1)
	targetMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	targetMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	animationId = requestAnimationFrame(animate);
	time += config.waveSpeed;

	// 平滑鼠标移动
	mouse.x += (targetMouse.x - mouse.x) * 0.05;
	mouse.y += (targetMouse.y - mouse.y) * 0.05;

	// 更新每个粒子的位置
	for (let i = 0; i < positions.length / 3; i++) {
		const x = originalPositions[i * 3];
		const z = originalPositions[i * 3 + 2];

		// 基础波浪效果 (多重正弦波叠加)
		let y =
			Math.sin(x * 0.05 + time * 50) * config.waveHeight +
			Math.sin(z * 0.05 + time * 30) * config.waveHeight * 0.5 +
			Math.sin((x + z) * 0.03 + time * 40) * config.waveHeight * 0.3;

		// 鼠标影响
		const mouseX = mouse.x * 200;
		const mouseY = mouse.y * 200;
		const distance = Math.sqrt(
			Math.pow(x - mouseX, 2) +
			Math.pow(z - mouseY, 2)
		);

		if (distance < config.mouseInfluence * 10) {
			const force = (1 - distance / (config.mouseInfluence * 10));
			y += force * config.mouseStrength;
		}

		positions[i * 3 + 1] = y;
	}

	// 更新几何体
	particles.geometry.attributes.position.needsUpdate = true;

	// 缓慢旋转视角
	particles.rotation.y = time * 5;

	renderer.render(scene, camera);
}

function cleanup() {
	window.removeEventListener('mousemove', onMouseMove);
	window.removeEventListener('resize', onWindowResize);
	if (animationId) {
		cancelAnimationFrame(animationId);
		animationId = 0;
	}
	if (renderer) {
		renderer.dispose();
		renderer = null as any;
	}
	if (particles) {
		particles.geometry.dispose();
		(particles.material as THREE.Material).dispose();
		scene.remove(particles);
		particles = null as any;
	}
	if (scene) {
		scene = null as any;
	}
}

// 初始化
if (typeof window !== 'undefined') {
	// 首次初始化
	init();

	// 页面卸载时清理
	window.addEventListener('beforeunload', cleanup);

	// Astro view transitions 支持
	document.addEventListener('astro:before-swap', cleanup);

	// 页面切换后重新初始化
	document.addEventListener('astro:after-swap', () => {
		// 延迟一帧确保 DOM 已更新
		requestAnimationFrame(() => {
			const canvas = document.getElementById('wave-background');
			if (canvas) {
				init();
			}
		});
	});
}
</script>

<style>
#wave-background {
	pointer-events: none;
}
</style>
